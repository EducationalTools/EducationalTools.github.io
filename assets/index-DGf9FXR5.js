import{l as I}from"./auth-client-CoRsmko_.js";import{c as S}from"./page-ClGUBbph.js";import"./chunk-JMJ3UQ3L-DLa4wvEN.js";import"./sha2-CO3l0I8W.js";import"./button-D7tyPeF-.js";import"./index-CPvIzByb.js";import"./bundle-mjs-BNe0Xlio.js";import"./utils-BB8OEnXs.js";import"./card-BpPdZkTd.js";import"./empty-Cg1BKJnV.js";import"./input-DE-BWp1k.js";import"./constants-DzlEtQAh.js";import"./ConvexAuthState-CCLe0bpr.js";import"./index-Dr94eIYd.js";import"./index-Bqq4DHLr.js";import"./index-vAMRNKaC.js";import"./alert-dialog-C5z3n2hc.js";import"./index-BoNYA7lJ.js";import"./index-CeJ37sa3.js";import"./index-RdSmrbPg.js";import"./state-DJ_Xbwdm.js";import"./experimental-check-BwBX2eWT.js";const Y=(f,R)=>{let w=null,j=S({config:{adapterId:"memory",adapterName:"Memory Adapter",usePlural:!1,debugLogs:R?.debugLogs||!1,customTransformInput(d){return(d.options.advanced?.database?.useNumberId||d.options.advanced?.database?.generateId==="serial")&&d.field==="id"&&d.action==="create"?f[d.model].length+1:d.data},transaction:async d=>{let M=structuredClone(f);try{return await d(j(w))}catch(A){throw Object.keys(f).forEach(v=>{f[v]=M[v]}),A}}},adapter:({getFieldName:d,options:M,getModelName:A})=>{const v=(e,n,c)=>n?e.sort((o,i)=>{const m=d({model:c,field:n.field}),u=o[m],t=i[m];let r=0;return u==null&&t==null?r=0:u==null?r=-1:t==null?r=1:typeof u=="string"&&typeof t=="string"?r=u.localeCompare(t):u instanceof Date&&t instanceof Date?r=u.getTime()-t.getTime():typeof u=="number"&&typeof t=="number"?r=u-t:typeof u=="boolean"&&typeof t=="boolean"?r=u===t?0:u?1:-1:r=String(u).localeCompare(String(t)),n.direction==="asc"?r:-r}):e;function h(e,n,c){const o=(t,r)=>{const y=f[r];if(!y)throw I.error(`[MemoryAdapter] Model ${r} not found in the DB`,Object.keys(f)),new Error(`Model ${r} not found`);const g=(s,p)=>{const{field:l,value:a,operator:b}=p;switch(b){case"in":if(!Array.isArray(a))throw new Error("Value must be an array");return a.includes(s[l]);case"not_in":if(!Array.isArray(a))throw new Error("Value must be an array");return!a.includes(s[l]);case"contains":return s[l].includes(a);case"starts_with":return s[l].startsWith(a);case"ends_with":return s[l].endsWith(a);case"ne":return s[l]!==a;case"gt":return a!=null&&s[l]>a;case"gte":return a!=null&&s[l]>=a;case"lt":return a!=null&&s[l]<a;case"lte":return a!=null&&s[l]<=a;default:return s[l]===a}};return y.filter(s=>{if(!t.length||t.length===0)return!0;let p=g(s,t[0]);for(const l of t){const a=g(s,l);l.connector==="OR"?p=p||a:p=p&&a}return p})};if(!c)return o(e,n);const i=o(e,n),m=new Map,u=new Map;for(const t of i){const r=String(t.id);if(!m.has(r)){const g={...t};for(const[s,p]of Object.entries(c)){const l=A(s);p.relation==="one-to-one"?g[l]=null:(g[l]=[],u.set(`${r}-${s}`,new Set))}m.set(r,g)}const y=m.get(r);for(const[g,s]of Object.entries(c)){const p=A(g),l=f[p];if(!l)throw I.error(`[MemoryAdapter] JoinOption model ${p} not found in the DB`,Object.keys(f)),new Error(`JoinOption model ${p} not found`);const a=l.filter(b=>b[s.on.to]===t[s.on.from]);if(s.relation==="one-to-one")y[p]=a[0]||null;else{const b=u.get(`${r}-${g}`),C=s.limit??100;let E=0;for(const O of a){if(E>=C)break;b.has(O.id)||(y[p].push(O),b.add(O.id),E++)}}}}return Array.from(m.values())}return{create:async({model:e,data:n})=>((M.advanced?.database?.useNumberId||M.advanced?.database?.generateId==="serial")&&(n.id=f[A(e)].length+1),f[e]||(f[e]=[]),f[e].push(n),n),findOne:async({model:e,where:n,join:c})=>{const o=h(n,e,c);if(c){const i=o;return i.length?i[0]:null}return o[0]||null},findMany:async({model:e,where:n,sortBy:c,limit:o,offset:i,join:m})=>{let u=h(n||[],e,m);if(m){const r=u;if(!r.length)return[];v(r,c,e);let y=r;return i!==void 0&&(y=y.slice(i)),o!==void 0&&(y=y.slice(0,o)),y}let t=v(u,c,e);return i!==void 0&&(t=t.slice(i)),o!==void 0&&(t=t.slice(0,o)),t||[]},count:async({model:e,where:n})=>n?h(n,e).length:f[e].length,update:async({model:e,where:n,update:c})=>{const o=h(n,e);return o.forEach(i=>{Object.assign(i,c)}),o[0]||null},delete:async({model:e,where:n})=>{const c=f[e],o=h(n,e);f[e]=c.filter(i=>!o.includes(i))},deleteMany:async({model:e,where:n})=>{const c=f[e],o=h(n,e);let i=0;return f[e]=c.filter(m=>o.includes(m)?(i++,!1):!o.includes(m)),i},updateMany({model:e,where:n,update:c}){const o=h(n,e);return o.forEach(i=>{Object.assign(i,c)}),o[0]||null}}}});return d=>(w=d,j(d))};export{Y as memoryAdapter};
