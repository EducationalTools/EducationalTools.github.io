import{C as o,D as c,a as l,b as u,s as m}from"./page-CovdJk3w.js";import"./chunk-UIGDSWPH-BVQp00Zd.js";import"./button-BtmAzGuo.js";import"./index-DstcrvaX.js";import"./bundle-mjs-BJeS7sC5.js";import"./utils-DL16pZsE.js";import"./card-BDP7RXBL.js";import"./empty-BPlBv7sK.js";import"./input-CFSxLv1b.js";import"./constants-hDAxwCjT.js";import"./createLucideIcon-Bmk5bfkH.js";import"./ConvexAuthState-DQPI8SxW.js";import"./auth-client-CkxdHvhw.js";import"./index-DveFINiG.js";import"./index-DdRqjIto.js";import"./sha2-3zd_KfSO.js";import"./alert-dialog-Dxd0_0Kt.js";import"./index-jf6C1AH_.js";import"./index-PsY7313p.js";import"./index-DdfkXwL2.js";import"./state-Cxcn9RdD.js";import"./experimental-check-BwBX2eWT.js";import"./arrow-right-DcOxzzrK.js";import"./copy-BPHNvrM9.js";class p{get supportsCreateIfNotExists(){return!0}get supportsTransactionalDdl(){return!1}get supportsReturning(){return!0}async acquireMigrationLock(){}async releaseMigrationLock(){}get supportsOutput(){return!0}}class h{#e;#t=new w;#r;#s;constructor(e){this.#e={...e}}async init(){this.#r=this.#e.database,this.#s=new y(this.#r),this.#e.onCreateConnection&&await this.#e.onCreateConnection(this.#s)}async acquireConnection(){return await this.#t.lock(),this.#s}async beginTransaction(e){await e.executeQuery(o.raw("begin"))}async commitTransaction(e){await e.executeQuery(o.raw("commit"))}async rollbackTransaction(e){await e.executeQuery(o.raw("rollback"))}async releaseConnection(){this.#t.unlock()}async destroy(){this.#r?.close()}}class y{#e;constructor(e){this.#e=e}executeQuery(e){const{sql:t,parameters:a}=e,i=this.#e.prepare(t).all(...a);return Promise.resolve({rows:i})}async*streamQuery(){throw new Error("Streaming query is not supported by SQLite driver.")}}class w{#e;#t;async lock(){for(;this.#e;)await this.#e;this.#e=new Promise(e=>{this.#t=e})}unlock(){const e=this.#t;this.#e=void 0,this.#t=void 0,e?.()}}class d{#e;constructor(e){this.#e=e}async getSchemas(){return[]}async getTables(e={withInternalKyselyTables:!1}){let t=this.#e.selectFrom("sqlite_schema").where("type","=","table").where("name","not like","sqlite_%").select("name").$castTo();e.withInternalKyselyTables||(t=t.where("name","!=",l).where("name","!=",u));const a=await t.execute();return Promise.all(a.map(({name:n})=>this.#t(n)))}async getMetadata(e){return{tables:await this.getTables(e)}}async#t(e){const t=this.#e,n=(await t.selectFrom("sqlite_master").where("name","=",e).select("sql").$castTo().execute())[0]?.sql?.split(/[\(\),]/)?.find(r=>r.toLowerCase().includes("autoincrement"))?.split(/\s+/)?.[0]?.replace(/["`]/g,""),i=await t.selectFrom(m`pragma_table_info(${e})`.as("table_info")).select(["name","type","notnull","dflt_value"]).execute();return{name:e,columns:i.map(r=>({name:r.name,dataType:r.type,isNullable:!r.notnull,isAutoIncrementing:r.name===n,hasDefaultValue:r.dflt_value!=null})),isView:!0}}}class g extends c{getCurrentParameterPlaceholder(){return"?"}getLeftIdentifierWrapper(){return'"'}getRightIdentifierWrapper(){return'"'}getAutoIncrement(){return"autoincrement"}}class B{#e;constructor(e){this.#e={...e}}createDriver(){return new h(this.#e)}createQueryCompiler(){return new g}createAdapter(){return new p}createIntrospector(e){return new d(e)}}export{p as NodeSqliteAdapter,B as NodeSqliteDialect,h as NodeSqliteDriver,d as NodeSqliteIntrospector,g as NodeSqliteQueryCompiler};
