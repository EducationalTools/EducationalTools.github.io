import{c as T,s as q}from"./page-ClGUBbph.js";import{d as ue,g as fe}from"./page-ClGUBbph.js";import"./auth-client-CoRsmko_.js";import"./chunk-JMJ3UQ3L-DLa4wvEN.js";import"./button-D7tyPeF-.js";import"./index-CPvIzByb.js";import"./bundle-mjs-BNe0Xlio.js";import"./utils-BB8OEnXs.js";import"./card-BpPdZkTd.js";import"./empty-Cg1BKJnV.js";import"./input-DE-BWp1k.js";import"./constants-DzlEtQAh.js";import"./ConvexAuthState-CCLe0bpr.js";import"./index-Dr94eIYd.js";import"./index-Bqq4DHLr.js";import"./index-vAMRNKaC.js";import"./sha2-CO3l0I8W.js";import"./alert-dialog-C5z3n2hc.js";import"./index-BoNYA7lJ.js";import"./index-CeJ37sa3.js";import"./index-RdSmrbPg.js";import"./state-DJ_Xbwdm.js";import"./experimental-check-BwBX2eWT.js";const le=(x,h)=>{let S=null;const v=m=>({getFieldName:w,schema:J,getDefaultFieldName:K,getDefaultModelName:L,getFieldAttributes:U,getModelName:_})=>{const k=i=>{const c=[],s=[];if(i)for(const[n,r]of Object.entries(i)){const e=J[L(n)]?.fields,[t,f]=n.includes(".")?n.split("."):[void 0,n];if(e){e.id={type:"string"};for(const[o,p]of Object.entries(e))c.push(q`${q.ref(`join_${f}`)}.${q.ref(p.fieldName||o)} as ${q.ref(`_joined_${f}_${p.fieldName||o}`)}`),s.push({joinModel:n,joinModelRef:f,fieldName:p.fieldName||o})}}return{allSelectsStr:s,allSelects:c}},$=async(i,c,s,n)=>{let r;if(h?.type==="mysql"){await c.execute();const e=i.id?"id":n.length>0&&n[0]?.field?n[0].field:"id";if(!i.id&&n.length===0)return r=await m.selectFrom(s).selectAll().orderBy(w({model:s,field:e}),"desc").limit(1).executeTakeFirst(),r;const t=i[e]||n[0]?.value;return r=await m.selectFrom(s).selectAll().orderBy(w({model:s,field:e}),"desc").where(w({model:s,field:e}),"=",t).limit(1).executeTakeFirst(),r}return h?.type==="mssql"?(r=await c.outputAll("inserted").executeTakeFirst(),r):(r=await c.returningAll().executeTakeFirst(),r)};function M(i,c){if(!c)return{and:null,or:null};const s={and:[],or:[]};return c.forEach(n=>{let{field:r,value:e,operator:t="=",connector:f="AND"}=n,o=e,p=w({model:i,field:r});const y=u=>{const l=`${i}.${p}`;return t.toLowerCase()==="in"?u(l,"in",Array.isArray(o)?o:[o]):t.toLowerCase()==="not_in"?u(l,"not in",Array.isArray(o)?o:[o]):t==="contains"?u(l,"like",`%${o}%`):t==="starts_with"?u(l,"like",`${o}%`):t==="ends_with"?u(l,"like",`%${o}`):t==="eq"?u(l,"=",o):t==="ne"?u(l,"<>",o):t==="gt"?u(l,">",o):t==="gte"?u(l,">=",o):t==="lt"?u(l,"<",o):t==="lte"?u(l,"<=",o):u(l,t,o)};f==="OR"?s.or.push(y):s.and.push(y)}),{and:s.and.length?s.and:null,or:s.or.length?s.or:null}}function F(i,c,s){if(!c||!i.length)return i;const n=new Map;for(const e of i){const t={},f={};for(const[y]of Object.entries(c))f[_(y)]={};for(const[y,u]of Object.entries(e)){const l=String(y);let a=!1;for(const{joinModel:d,fieldName:A,joinModelRef:j}of s)if(l===`_joined_${j}_${A}`){f[_(d)][w({model:d,field:A})]=u,a=!0;break}a||(t[y]=u)}const o=t.id;if(!o)continue;if(!n.has(o)){const y={...t};for(const[u,l]of Object.entries(c))y[_(u)]=l.relation==="one-to-one"?null:[];n.set(o,y)}const p=n.get(o);for(const[y,u]of Object.entries(c)){const l=u.relation==="one-to-one",a=u.limit??100,d=f[_(y)],A=d&&Object.keys(d).length>0&&Object.values(d).some(j=>j!=null);if(l)p[_(y)]=A?d:null;else{const j=_(y);if(Array.isArray(p[j])&&A){if(p[j].length>=a)continue;const R=w({model:y,field:"id"}),I=d[R];I?!p[j].some(g=>g[R]===I)&&p[j].length<a&&p[j].push(d):p[j].length<a&&p[j].push(d)}}}}let r=Array.from(n.values());for(const e of r)for(const[t,f]of Object.entries(c))if(f.relation!=="one-to-one"){const o=_(t);if(Array.isArray(e[o])){const p=f.limit??100;e[o].length>p&&(e[o]=e[o].slice(0,p))}}return r}return{async create({data:i,model:c}){return await $(i,m.insertInto(c).values(i),c,[])},async findOne({model:i,where:c,select:s,join:n}){const{and:r,or:e}=M(i,c);let t=m.selectFrom(u=>{let l=u.selectFrom(i);return r&&(l=l.where(a=>a.and(r.map(d=>d(a))))),e&&(l=l.where(a=>a.or(e.map(d=>d(a))))),l.selectAll().as("primary")}).selectAll("primary");if(n)for(const[u,l]of Object.entries(n)){const[a,d]=u.includes(".")?u.split("."):[void 0,u];t=t.leftJoin(`${u} as join_${d}`,A=>A.onRef(`join_${d}.${l.on.to}`,"=",`primary.${l.on.from}`))}const{allSelectsStr:f,allSelects:o}=k(n);t=t.select(o);const p=await t.execute();if(!p||!Array.isArray(p)||p.length===0)return null;const y=p[0];return n?F(p,n,f)[0]:y},async findMany({model:i,where:c,limit:s,offset:n,sortBy:r,join:e}){const{and:t,or:f}=M(i,c);let o=m.selectFrom(l=>{let a=l.selectFrom(i);return h?.type==="mssql"?n!==void 0?(r||(a=a.orderBy(w({model:i,field:"id"}))),a=a.offset(n).fetch(s||100)):s!==void 0&&(a=a.top(s)):(s!==void 0&&(a=a.limit(s)),n!==void 0&&(a=a.offset(n))),r?.field&&(a=a.orderBy(`${w({model:i,field:r.field})}`,r.direction)),t&&(a=a.where(d=>d.and(t.map(A=>A(d))))),f&&(a=a.where(d=>d.or(f.map(A=>A(d))))),a.selectAll().as("primary")}).selectAll("primary");if(e)for(const[l,a]of Object.entries(e)){const[d,A]=l.includes(".")?l.split("."):[void 0,l];o=o.leftJoin(`${l} as join_${A}`,j=>j.onRef(`join_${A}.${a.on.to}`,"=",`primary.${a.on.from}`))}const{allSelectsStr:p,allSelects:y}=k(e);o=o.select(y),r?.field&&(o=o.orderBy(`${w({model:i,field:r.field})}`,r.direction));const u=await o.execute();return u?e?F(u,e,p):u:[]},async update({model:i,where:c,update:s}){const{and:n,or:r}=M(i,c);let e=m.updateTable(i).set(s);return n&&(e=e.where(t=>t.and(n.map(f=>f(t))))),r&&(e=e.where(t=>t.or(r.map(f=>f(t))))),await $(s,e,i,c)},async updateMany({model:i,where:c,update:s}){const{and:n,or:r}=M(i,c);let e=m.updateTable(i).set(s);return n&&(e=e.where(t=>t.and(n.map(f=>f(t))))),r&&(e=e.where(t=>t.or(r.map(f=>f(t))))),(await e.execute()).length},async count({model:i,where:c}){const{and:s,or:n}=M(i,c);let r=m.selectFrom(i).select(m.fn.count("id").as("count"));s&&(r=r.where(t=>t.and(s.map(f=>f(t))))),n&&(r=r.where(t=>t.or(n.map(f=>f(t)))));const e=await r.execute();return typeof e[0].count=="number"?e[0].count:typeof e[0].count=="bigint"?Number(e[0].count):parseInt(e[0].count)},async delete({model:i,where:c}){const{and:s,or:n}=M(i,c);let r=m.deleteFrom(i);s&&(r=r.where(e=>e.and(s.map(t=>t(e))))),n&&(r=r.where(e=>e.or(n.map(t=>t(e))))),await r.execute()},async deleteMany({model:i,where:c}){const{and:s,or:n}=M(i,c);let r=m.deleteFrom(i);return s&&(r=r.where(e=>e.and(s.map(t=>t(e))))),n&&(r=r.where(e=>e.or(n.map(t=>t(e))))),(await r.execute()).length},options:h}};let O=null;O={config:{adapterId:"kysely",adapterName:"Kysely Adapter",usePlural:h?.usePlural,debugLogs:h?.debugLogs,supportsBooleans:!(h?.type==="sqlite"||h?.type==="mssql"||h?.type==="mysql"||!h?.type),supportsDates:!(h?.type==="sqlite"||h?.type==="mssql"||!h?.type),supportsJSON:!1,supportsUUIDs:h?.type==="postgres",transaction:h?.transaction?m=>x.transaction().execute(w=>m(T({config:O.config,adapter:v(w)})(S))):!1},adapter:v(x)};const D=T(O);return m=>(S=m,D(m))};export{ue as createKyselyAdapter,fe as getKyselyDatabaseType,le as kyselyAdapter};
